# Gnosis Card Portfolio Dashboard - Cursor Rules

You are an expert senior developer working on a financial dashboard for Gnosis Pay card users. This project uses Domain Driven Design, strict TypeScript, and modern React patterns.

## Project Overview

- **Name**: Gnosis Card Portfolio Dashboard
- **Stack**: Next.js 15, React 19, tRPC v11, Tailwind CSS v4, Shadcn/UI
- **Runtime**: Bun (NOT npm/pnpm/yarn)
- **Architecture**: Domain Driven Design (DDD) with monorepo
- **Styling**: Dark mode first, rounded borders (12px default)

---

## üö® MANDATORY Workflow Rules

### Before Writing ANY Code

1. **Search the codebase first** - Check if similar components, hooks, or utilities already exist
2. **Check existing patterns** - Look at how similar features are implemented
3. **Review the constants package** - Ensure enums/configs exist before creating new ones
4. **Read relevant documentation** - Check `docs/` folder for architecture decisions

```bash
# Before creating a new component, search for existing ones
grep -r "ComponentName" apps/web/components
grep -r "useHookName" apps/web/features
```

### After Completing Each Task

1. **Run linting** - Fix ALL errors before moving on

```bash
bun run lint
bun run typecheck
```

2. **Run tests** - Ensure nothing is broken

```bash
bun test
```

3. **Update task list** - Mark completed tasks in `docs/tasks.md`

```markdown
// Change from:
- [ ] Create TransactionRow component

// To:
- [x] Create TransactionRow component
```

4. **Update documentation if needed** - Keep docs in sync with code changes
   - `docs/architecture.md` - If architecture changes
   - `docs/design.md` - If UI patterns change
   - `docs/requirements.md` - If features change

### Commit Strategy

**Commit after completing each logical unit of work:**

```bash
# After completing a component
git add .
git commit -m "feat(transactions): add TransactionRow component"

# After completing a feature
git add .
git commit -m "feat(auth): implement SIWE authentication flow"

# After fixing bugs
git add .
git commit -m "fix(transactions): correct currency formatting"

# After refactoring
git add .
git commit -m "refactor(domain): extract Money value object"
```

**Commit message format:** `type(scope): description`

| Type | When to use |
|------|-------------|
| `feat` | New feature |
| `fix` | Bug fix |
| `refactor` | Code refactoring |
| `docs` | Documentation changes |
| `test` | Adding tests |
| `chore` | Maintenance tasks |

**Milestone commits (larger features):**

```bash
git commit -m "feat(transactions): complete transaction list feature

- Add TransactionRow component
- Add TransactionList organism
- Add useTransactions hook
- Add transaction filtering
- Update tasks.md with completed items"
```

### Quality Checklist (Before Moving to Next Task)

- [ ] Code compiles without errors (`bun run typecheck`)
- [ ] Linting passes (`bun run lint`)
- [ ] Tests pass (`bun test`)
- [ ] No `any` types used
- [ ] No magic numbers
- [ ] Using enums from constants package
- [ ] File is under 500 lines
- [ ] Functions are under 30 lines
- [ ] Logic decoupled from UI (complex logic in hooks)
- [ ] Task marked complete in `docs/tasks.md`
- [ ] Changes committed with proper message

### Do NOT Proceed If

‚ùå There are TypeScript errors
‚ùå There are ESLint errors
‚ùå Tests are failing
‚ùå You haven't checked for existing code
‚ùå You're duplicating existing functionality

---

## Critical Rules

### 1. File Size Limits

- **Max 500 lines per file** - Split into smaller modules if exceeded
- **Max 30 lines per function** - Extract helper functions
- **Max complexity of 10** - Simplify nested logic

### 2. No Magic Numbers

```typescript
// ‚ùå BAD
if (gnoBalance >= 100) { ... }
setTimeout(() => {}, 300000);

// ‚úÖ GOOD
import { CASHBACK_TIER_CONFIG } from '@payments-view/constants';
import { AUTH_CONFIG } from '@payments-view/constants';

if (gnoBalance >= CASHBACK_TIER_CONFIG[4].minGno) { ... }
setTimeout(() => {}, AUTH_CONFIG.JWT_EXPIRY_BUFFER_MS);
```

### 3. Enums Over Literal Strings

```typescript
// ‚ùå BAD
if (transaction.kind === 'Payment') { ... }
if (status === 'Approved') { ... }

// ‚úÖ GOOD
import { TransactionKind, TransactionStatus } from '@payments-view/constants';

if (transaction.kind === TransactionKind.PAYMENT) { ... }
if (status === TransactionStatus.APPROVED) { ... }
```

### 4. Result Type for Error Handling

```typescript
// ‚ùå BAD - Throwing errors
async function getTransaction(id: string): Promise<Transaction> {
  const result = await api.get(id);
  if (!result) throw new Error('Not found');
  return result;
}

// ‚úÖ GOOD - Result type
import { Result } from '@payments-view/domain/shared';

async function getTransaction(id: string): Promise<Result<Transaction, NotFoundError>> {
  const result = await api.get(id);
  if (!result) return Result.err(new NotFoundError(id));
  return Result.ok(result);
}
```

## Architecture Layers

### Domain Layer (`packages/domain`)

- Pure business logic, NO external dependencies
- Entities, Value Objects, Domain Services
- No I/O operations (no fetch, no database)

```typescript
// packages/domain/src/transaction/value-objects/money.ts
export class Money {
  private constructor(
    private readonly _amount: bigint,
    private readonly _currency: CurrencyCode,
    private readonly _decimals: number
  ) {}

  static create(amount: string, currency: CurrencyCode, decimals: number): Money {
    return new Money(BigInt(amount), currency, decimals);
  }

  toNumber(): number {
    return Number(this._amount) / Math.pow(10, this._decimals);
  }
}
```

### Application Layer (`packages/application`)

- Use cases / Application services
- Orchestrates domain objects
- Returns Result<T, E> types

```typescript
// packages/application/src/use-cases/transactions/list-transactions.use-case.ts
export class ListTransactionsUseCase {
  constructor(private readonly repo: TransactionRepository) {}

  async execute(input: ListTransactionsInput): Promise<Result<TransactionsOutput, Error>> {
    // Orchestration logic here
  }
}
```

### Infrastructure Layer (`packages/infrastructure`)

- External API clients (Gnosis Pay, OpenAI)
- Repository implementations
- Mappers (API ‚Üí Domain)

### API Layer (`packages/api`)

- tRPC routers and procedures
- Input validation with Zod
- Calls use cases from application layer

### UI Layer (`apps/web`)

- Next.js App Router pages
- React components (Atomic Design)
- Feature modules with hooks

## File Organization

```
packages/
‚îú‚îÄ‚îÄ constants/src/
‚îÇ   ‚îú‚îÄ‚îÄ enums/           # All enums (TransactionKind, Status, etc.)
‚îÇ   ‚îú‚îÄ‚îÄ config/          # Configuration constants (API, Auth, etc.)
‚îÇ   ‚îî‚îÄ‚îÄ mappings/        # MCC category mappings
‚îú‚îÄ‚îÄ domain/src/
‚îÇ   ‚îú‚îÄ‚îÄ transaction/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ entities/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ value-objects/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ repositories/  # Interfaces only!
‚îÇ   ‚îî‚îÄ‚îÄ shared/
‚îÇ       ‚îú‚îÄ‚îÄ errors/
‚îÇ       ‚îî‚îÄ‚îÄ types/
‚îú‚îÄ‚îÄ application/src/
‚îÇ   ‚îî‚îÄ‚îÄ use-cases/
‚îú‚îÄ‚îÄ infrastructure/src/
‚îÇ   ‚îú‚îÄ‚îÄ gnosis-pay/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ schemas/        # Zod schemas for API validation (source of truth!)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ types/          # TypeScript types
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ client.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mappers/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ repositories/
‚îÇ   ‚îî‚îÄ‚îÄ logging/
‚îú‚îÄ‚îÄ api/src/
‚îÇ   ‚îú‚îÄ‚îÄ routers/
‚îÇ   ‚îú‚îÄ‚îÄ middleware/
‚îÇ   ‚îî‚îÄ‚îÄ context.ts
‚îî‚îÄ‚îÄ ui/src/
    ‚îú‚îÄ‚îÄ primitives/      # Shadcn atoms (Button, Card, Input, Tooltip, Dialog, etc.)
    ‚îú‚îÄ‚îÄ components/      # Reusable atoms/molecules/feedback (SegmentedControl, StatCard, ToastProvider, ErrorBoundary)
    ‚îî‚îÄ‚îÄ theme/           # Tokens/radius/colors (source of truth)

apps/web/
‚îú‚îÄ‚îÄ app/                 # Next.js App Router
‚îÇ   ‚îú‚îÄ‚îÄ (auth)/
‚îÇ   ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ   ‚îî‚îÄ‚îÄ api/trpc/
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ atoms/           # App-specific atoms only (brand or app-only)
‚îÇ   ‚îú‚îÄ‚îÄ molecules/       # App-level composites; prefer packages/ui for reusable pieces
‚îÇ   ‚îú‚îÄ‚îÄ organisms/       # (Use features/ instead when domain-specific)
‚îÇ   ‚îî‚îÄ‚îÄ templates/       # Layouts/shells (DashboardLayout, etc.)
‚îú‚îÄ‚îÄ features/            # Feature modules
‚îÇ   ‚îú‚îÄ‚îÄ auth/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ hooks/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ components/
‚îÇ   ‚îî‚îÄ‚îÄ transactions/
‚îî‚îÄ‚îÄ lib/
```

## Naming Conventions

### Files

- `kebab-case` for all files: `transaction-list.tsx`, `use-auth.ts`
- Suffix by type: `.service.ts`, `.use-case.ts`, `.repository.ts`, `.mapper.ts`
- Test files: `money.test.ts` (same directory or `__tests__` folder)

### Code

- `PascalCase`: Components, Classes, Types, Interfaces, Enums
- `camelCase`: Functions, variables, hooks
- `SCREAMING_SNAKE_CASE`: Constants only in config files
- Prefix interfaces with `I` only for dependency injection: `ILogger`, `ITransactionRepository`

### Components

```typescript
// Component file: transaction-row.tsx
export interface TransactionRowProps {
  transaction: Transaction;
  onSelect?: (id: string) => void;
}

export function TransactionRow({ transaction, onSelect }: TransactionRowProps) {
  // ...
}
```

### Hooks

```typescript
// Hook file: use-transactions.ts
export function useTransactions(options?: UseTransactionsOptions) {
  // Always return object, not tuple
  return {
    transactions,
    isLoading,
    error,
    refetch,
  };
}
```

### 5. Decouple Logic from UI

**Always separate business logic from UI components.** Complex data processing, calculations, and state management should live in custom hooks, while components should only handle rendering.

```typescript
// ‚ùå BAD - Logic mixed with UI
export function SpendingChart({ transactions }: Props) {
  const [period, setPeriod] = useState('month');

  // Business logic mixed in component
  const filtered = useMemo(() => {
    const threshold = getDateThreshold(period);
    return transactions.filter(tx => new Date(tx.createdAt) >= threshold);
  }, [transactions, period]);

  const aggregated = useMemo(() => {
    const map = new Map();
    for (const tx of filtered) {
      // ... 50 lines of aggregation logic
    }
    return result;
  }, [filtered]);

  return <Chart data={aggregated} />;
}

// ‚úÖ GOOD - Logic in hook, UI in component
// hooks/use-spending-chart.ts
export function useSpendingChart({ transactions }: Options) {
  const [period, setPeriod] = useState('month');

  const filtered = useMemo(
    () => filterByTimePeriod(transactions, period),
    [transactions, period]
  );

  const aggregated = useMemo(
    () => aggregateByCategory(filtered),
    [filtered]
  );

  return { period, setPeriod, aggregated, filtered };
}

// components/spending-chart.tsx
export function SpendingChart({ transactions }: Props) {
  const { period, setPeriod, aggregated } = useSpendingChart({ transactions });

  return <Chart data={aggregated} />;
}
```

**Benefits:**
- Hooks are testable without rendering components
- Components stay focused on presentation
- Logic can be reused across multiple components
- Easier to understand and maintain
- Better separation of concerns

**When to extract to a hook:**
- Component has > 50 lines of useMemo/useCallback logic
- Same logic needed in multiple components
- Complex state transformations or calculations
- Data fetching with loading/error states

## Component Patterns

### Atomic Design Hierarchy

1. **Atoms**: Button, Badge, Input, Skeleton
2. **Molecules**: TransactionRow, StatCard, SearchBar
3. **Organisms**: TransactionList, SpendingChart, FilterPanel
4. **Templates**: DashboardLayout, AuthLayout

### UI Placement Rules

- Use `@payments-view/ui` for primitives and shared atoms/molecules/feedback (Button, Card, SegmentedControl, StatCard, ToastProvider, ErrorBoundary).
- Only create atoms/molecules in `apps/web/src/components` when they are app-specific/brand-only; generic ones belong in `packages/ui/src/components` and must be re-exported there.
- Domain-specific UI stays under `apps/web/src/features/<domain>/components`; keep pages thin and compose feature components.
- Layout chrome lives in `apps/web/src/components/templates` (sidebar/topbar/shell); avoid routing/auth logic inside design-system components.
- When adding reusable UI, update `packages/ui/src/index.ts` exports and import directly from `@payments-view/ui`.

### Component Structure

```tsx
// 1. Imports (organized)
import { useState, useCallback } from 'react';

import { Card, CardContent } from '@payments-view/ui';
import { TransactionKind } from '@payments-view/constants';

import { useTransactions } from '@/features/transactions';
import { cn } from '@/lib/utils/cn';

// 2. Types
interface TransactionListProps {
  className?: string;
  limit?: number;
}

// 3. Component
export function TransactionList({ className, limit }: TransactionListProps) {
  // Hooks first
  const { transactions, isLoading } = useTransactions({ limit });

  // Derived state
  const isEmpty = transactions.length === 0;

  // Callbacks
  const handleSelect = useCallback((id: string) => {
    // ...
  }, []);

  // Early returns for loading/error/empty
  if (isLoading) return <TransactionListSkeleton />;
  if (isEmpty) return <EmptyState />;

  // Main render
  return (
    <div className={cn('space-y-3', className)}>
      {transactions.map((tx) => (
        <TransactionRow key={tx.id} transaction={tx} onSelect={handleSelect} />
      ))}
    </div>
  );
}
```

## Styling Rules

### Design Tokens

- Source of truth for colors/radius/spacing is `packages/ui/src/theme`; avoid duplicating tokens in app-level CSS‚Äîif tokens change, update the UI package and consume it.

### Tailwind Classes

```tsx
// ‚ùå BAD - Inline styles, inconsistent
<div style={{ borderRadius: '12px' }}>
<div className="rounded-md">  // Wrong radius

// ‚úÖ GOOD - Use theme values
<div className="rounded-2xl">  // 24px for cards
<div className="rounded-xl">   // 16px for inner elements
<div className="rounded-lg">   // 12px default
```

### Dark Mode First

```tsx
// Colors should work in dark mode by default
<div className="bg-card text-card-foreground">
<span className="text-muted-foreground">
<div className="border-border">
```

### Spacing

```tsx
// Use consistent spacing scale
<div className="p-4">        // 16px padding
<div className="space-y-3">  // 12px gap
<div className="gap-4">      // 16px flex gap
```

## Import Organization

```typescript
// 1. React/Next.js
import { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';

// 2. External packages
import { z } from 'zod';

// 3. Internal packages (@payments-view/*)
import { TransactionKind } from '@payments-view/constants';
import { Money } from '@payments-view/domain/transaction';

// 4. Local imports (@/*)
import { useAuth } from '@/features/auth';
import { cn } from '@/lib/utils/cn';

// 5. Relative imports
import { TransactionRow } from './transaction-row';

// 6. Types (always last with 'type' keyword)
import type { Transaction } from '@payments-view/domain/transaction';
```

## Bun Commands

Always use `bun` instead of npm/pnpm:

```bash
# Install dependencies
bun install

# Run dev server
bun dev

# Run tests
bun test

# Add package
bun add <package>

# Add dev dependency
bun add -D <package>

# Run script
bun run <script>

# Execute package binary
bunx <command>
```

## Testing Patterns

```typescript
// Use bun:test
import { describe, test, expect, beforeEach, mock } from 'bun:test';

describe('Money', () => {
  test('should format currency correctly', () => {
    const money = Money.create('2550', 'EUR', 2);
    expect(money.format()).toBe('‚Ç¨25.50');
  });
});

// Mock external dependencies
const mockFetch = mock(() => Promise.resolve({ ok: true, json: () => ({}) }));
```

## Error Messages

Always provide user-friendly error messages:

```typescript
// ‚ùå BAD
throw new Error('INVALID_INPUT');

// ‚úÖ GOOD
throw new ValidationError([
  { field: 'amount', message: 'Amount must be greater than 0', code: 'invalid_range' }
]);
```

## API Patterns

### tRPC Procedures

```typescript
// packages/api/src/routers/transaction.router.ts
export const transactionRouter = router({
  list: protectedProcedure
    .input(listTransactionsSchema)
    .query(async ({ ctx, input }) => {
      const useCase = new ListTransactionsUseCase(ctx.transactionRepo);
      const result = await useCase.execute({ ...input, token: ctx.token });

      if (result.isFailure) {
        throw handleError(result.error, ctx.correlationId);
      }

      return result.value;
    }),
});
```

## üåê External API Integration (CRITICAL)

When integrating with external APIs (Gnosis Pay, etc.), type mismatches between our code and actual API responses cause runtime crashes. Follow these rules strictly:

### Before Writing ANY API Integration

1. **Read the official API documentation first**
   - Find the exact endpoint documentation
   - Note the exact field names (e.g., `token` vs `jwt`, `signerAddress` vs `sub`)
   - Check for nullable/optional fields
   - Look for nested object structures

2. **Check existing schemas in `packages/infrastructure/src/gnosis-pay/schemas/`**

### Mandatory Steps for API Types

```typescript
// ‚ùå BAD - Guessing field names
interface ApiResponse {
  jwt: string;        // Assumed field name
  sub: string;        // Standard JWT claim - but API might use different field!
}

// ‚úÖ GOOD - Verified against official docs
/**
 * Challenge response from /api/v1/auth/challenge
 * Docs: https://docs.gnosispay.com/api-reference/authentication/verify-siwe-signature
 * Verified: 2024-11-26
 */
interface ChallengeResponse {
  token: string;  // API returns 'token', not 'jwt'
}

/**
 * JWT payload from Gnosis Pay
 * Note: Uses 'signerAddress' instead of standard 'sub' claim
 */
interface JwtPayload {
  userId: string;
  signerAddress: string;  // NOT 'sub'!
  chainId: number;
  exp: number;
  iat: number;
}
```

### Create Zod Schemas for Runtime Validation

```typescript
// packages/infrastructure/src/gnosis-pay/schemas/auth.schema.ts
import { z } from 'zod';

/**
 * Always add doc link and verification date
 * Docs: https://docs.gnosispay.com/api-reference/...
 * Verified: YYYY-MM-DD
 */
export const ChallengeResponseSchema = z.object({
  token: z.string(),
}).passthrough(); // Allow unknown fields

// Use runtime validation in clients
const result = ChallengeResponseSchema.safeParse(apiResponse);
if (!result.success) {
  console.error('[API Schema] Validation failed:', result.error.issues);
}
```

### API Integration Checklist

```
‚ñ° Read official API documentation
‚ñ° Document the exact endpoint URL in comments
‚ñ° Use EXACT field names from docs (not assumptions)
‚ñ° Create Zod schema for runtime validation
‚ñ° Add .passthrough() to allow unknown fields
‚ñ° Handle nullable fields with .nullable().optional()
‚ñ° Add doc URL and verification date in comments
‚ñ° Test with real API responses
‚ñ° Log actual response structure in development
```

### Common Gotchas

| What We Assumed | What API Actually Returns |
|-----------------|---------------------------|
| `jwt` | `token` |
| `sub` (standard JWT) | `signerAddress` |
| `isEligibleForCashback` | `impactsCashback` |
| `merchant.country: string` | `merchant.country: { name, alpha2, ... }` |
| `billingAmount: { value, currency }` | `billingAmount: string` + `billingCurrency: object` |

### File Organization for API Types

```
packages/infrastructure/src/gnosis-pay/
‚îú‚îÄ‚îÄ schemas/           # Zod schemas (source of truth)
‚îÇ   ‚îú‚îÄ‚îÄ auth.schema.ts
‚îÇ   ‚îú‚îÄ‚îÄ transaction.schema.ts
‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îú‚îÄ‚îÄ types/             # TypeScript types (derived from schemas)
‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îú‚îÄ‚îÄ mappers/           # API response ‚Üí Domain entity mappers
‚îÇ   ‚îî‚îÄ‚îÄ transaction.mapper.ts
‚îî‚îÄ‚îÄ client.ts          # HTTP client with dev logging
```

---

## Things to AVOID

1. **Any type**: Never use `any`, use `unknown` and narrow types
2. **Console.log in production**: Use the logger from infrastructure
3. **Direct API calls in components**: Always go through tRPC
4. **Inline styles**: Use Tailwind classes
5. **Magic strings**: Use enums from constants package
6. **Throwing errors**: Use Result type pattern
7. **Large files**: Split if > 500 lines
8. **Complex functions**: Split if > 30 lines
9. **npm/pnpm commands**: Use bun
10. **Non-dark-mode colors**: Use CSS variables
11. **Skipping linting**: Always run `bun run lint` before moving on
12. **Creating duplicate code**: Search codebase first for existing solutions
13. **Ignoring tests**: Run `bun test` after changes
14. **Forgetting to update docs**: Keep documentation in sync
15. **Uncommitted work**: Commit after completing each task
16. **Guessing API field names**: Always verify against official documentation
17. **Skipping Zod validation**: Always validate external API responses at runtime
18. **Mixing logic with UI**: Extract business logic to custom hooks, keep components focused on rendering

---

## üìã Task Management

### Task File Location

All tasks are tracked in `docs/tasks.md`

### Marking Tasks Complete

```markdown
// When starting a task:
- [ ] Create TransactionRow component  ‚Üê Currently working on

// When task is complete:
- [x] Create TransactionRow component  ‚Üê Done!
```

### Task Completion Workflow

1. Complete the implementation
2. Run `bun run lint` - fix any errors
3. Run `bun run typecheck` - fix any type errors
4. Run `bun test` - ensure tests pass
5. Update `docs/tasks.md` - mark task as complete
6. Commit with appropriate message
7. Move to next task

---

## üìö Documentation Updates

### When to Update Documentation

| Document | Update When |
|----------|-------------|
| `docs/requirements.md` | Feature requirements change |
| `docs/architecture.md` | Architecture decisions change, new patterns introduced |
| `docs/design.md` | UI patterns change, new components added |
| `docs/tasks.md` | Tasks completed, new tasks identified |

### Documentation Update Checklist

- [ ] Is the change significant enough to document?
- [ ] Does it affect how other developers work?
- [ ] Will future you need to remember this?

If yes to any, update the relevant doc!

---

## Quick Reference

| Pattern | Location |
|---------|----------|
| Enums | `@payments-view/constants/enums` |
| Config | `@payments-view/constants/config` |
| Domain entities | `@payments-view/domain/<domain>/entities` |
| Value objects | `@payments-view/domain/<domain>/value-objects` |
| Use cases | `@payments-view/application/use-cases` |
| API clients | `@payments-view/infrastructure/<service>` |
| **API Schemas (Zod)** | `@payments-view/infrastructure/<service>/schemas` |
| tRPC routers | `@payments-view/api/routers` |
| UI primitives | `@payments-view/ui/primitives` |
| Feature hooks | `@/features/<feature>/hooks` |
| Components | `@/components/<atomic-level>` |

---

## üîç Before Creating Anything New

### Search Commands

```bash
# Search for existing components
grep -r "ComponentName" apps/web/components/
rg "ComponentName" packages/ui/src/components

# Search for existing hooks
grep -r "useHookName" apps/web/features/

# Search for existing utilities
grep -r "functionName" packages/

# Search for existing types
grep -r "TypeName" packages/domain/

# Search for existing constants
grep -r "CONSTANT_NAME" packages/constants/
```

### Questions to Ask

1. Does this component/hook/utility already exist?
2. Is there a similar pattern I can extend?
3. Can I reuse code from another feature?
4. Is this the right architectural layer for this code?
5. Should this UI live in `packages/ui` instead of the app/feature?

---

## ‚úÖ Final Checklist (Use Before Every Commit)

```
‚ñ° Searched codebase for existing code
‚ñ° No TypeScript errors (bun run typecheck)
‚ñ° No ESLint errors (bun run lint)
‚ñ° Tests pass (bun test)
‚ñ° No `any` types
‚ñ° No magic numbers (using constants)
‚ñ° Using enums (not string literals)
‚ñ° Files under 500 lines
‚ñ° Functions under 30 lines
‚ñ° Logic decoupled from UI (hooks for business logic)
‚ñ° Updated docs/tasks.md
‚ñ° Updated relevant documentation
‚ñ° Meaningful commit message
```
